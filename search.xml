<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>初入JVM</title>
      <link href="2021/06/07/chu-ru-jvm/"/>
      <url>2021/06/07/chu-ru-jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a><strong>JVM</strong></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。<br>引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行</p><h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a><strong>组成部分</strong></h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a><strong>堆</strong></h3><h4 id="作用：用来存储对象"><a href="#作用：用来存储对象" class="headerlink" title="作用：用来存储对象"></a>作用：用来存储对象</h4><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul><li>新生代<ul><li>组成<br>Eden（伊甸园）<br>Survivor(Survivor0,Survivor1)</li><li>空间分配比例<br>Eden : Survivor0 : Survivor1 = 8 : 1 : 1</li><li>记忆集<br><strong>概念：</strong> 当年轻代里有被有被老年代引用的对象时，会在年轻代理开辟空间老年代的引用地址，用来避免年轻代里对象无法回收的问题。<br><strong>作用：</strong> 用来存储存储所有有指针指向新生代的老年代对象的引用地址。<br><strong>卡表：</strong> 记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。使用写屏障来实现卡表元素变脏。写屏障分为写前屏障和写后屏障，大多数垃圾收集器都是使用写后屏障（G1使用写前屏障）。写后屏障具体表现在对引用对象赋值时，如果是跨代引用，则通过写后屏障将对应的卡表元素变脏。</li></ul></li><li>老年代<br>  老年代中存放的对象是存活了很久的，年龄大于15的对象。</li><li>内存占比：<br>  新生代 : 老年代 = 1 : 2</li><li>方法区（永久代）<br>  所有线程共享的内存区域，存储一些静态常量，类信息等。一般不回收。</li></ul><hr><h4 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h4><ol><li>创建对象</li><li>储存到Eden伊甸园区</li><li>存满之后字节码执行引擎开启垃圾回收线程minor gc</li><li>将找到的非垃圾回收对象转入到 <strong>survivor</strong> 的 <strong>s0</strong> 区域中。将Eden，s0和s1内所有垃圾对象进行回收，当s0区域内的对象再次筛选时 <strong>仍</strong> 被标记为非垃圾对象。</li><li>对象被复制到s1区,Eden、s0、s1区域内所有对象进行回收，将对象再次复制到s0区域。</li><li>分代年龄加1，分代年龄存储在对象头内存区域Header</li><li>当分代年龄达到15就会被复制到老年代</li><li>当老年代满了之后，执行引擎开启full gc</li><li>如果full gc无法再回收垃圾对象，则内存溢出（oom）</li></ol><hr><h4 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h4><ul><li>算法原理  <pre class="line-numbers language-none"><code class="language-none">标记清除算法(Mark-Sweep)缺点：容易产生碎片空间，内存不连续。复制算法(Copying)优点：不会产生碎片空间。缺点：比较浪费空间。标记整理压缩算法(Mark-Compact)优点：没有碎片空间缺点：效率比较低<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>算法分类<ul><li>引用计数器算法（很少使用）<br>  给对象添加一个引用计数器，每当有一个地方引用它，计数器值就加一；相反的，当引用失效的时候，计数器值就减一；任何时刻计数器为0的对象就是不可能再被使用。<br>  缺点：当存在堆内对象相互引用的情况无法进行计数器清0，但实际上已经没有引用，导致无法回收。如:    <pre class="line-numbers language-java" data-language="java"><code class="language-java">Node a &#x3D; new Node();Node b &#x3D; new Node();a.next &#x3D; b;b.next &#x3D; a;a &#x3D; null;b &#x3D; null;&#x2F;&#x2F;a,b变量已经变为null，失去了栈与堆对象之间的联系，所以堆对象应该做清除，但是此时还是有a和b之间的引用，计数器不是0，即无法做垃圾回收。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>可达性分析算法（jvm使用）<br>  GC roots跟节点：包含线程栈的本地变量，静态变量，本地方法栈变量，方法区的变量等。<br>  原理：将GC roots跟节点作为起点，从节点开始向下搜索引用的对象，找到的对象都标记为非垃圾对象，其余均为垃圾对象。<br>  过程：将jvm内的所有跟节点及其引用对象找出来，标记为垃圾和非垃圾。</li></ul></li></ul><hr><h4 id="垃圾回收处理器分类"><a href="#垃圾回收处理器分类" class="headerlink" title="垃圾回收处理器分类"></a>垃圾回收处理器分类</h4><ul><li><p>parallel scavenge + Parallel Old;是jdk8默认的垃圾收集器,jdk9之后使用g1作为默认。<br>  <img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/Baize0805/img@master/xxx.6x5eb6hxzfg0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="垃圾收集器"></p></li><li><p>串行收集器（jdk1.0默认使用）<br>  serial 年轻代采用复制算法，因其是属于单线程，故执行效率较慢。<br>  serial old 老年代采用整理算法，因其是属于单线程，故执行效率较慢。</p></li><li><p>并行收集器（jdk8默认使用）<br>  parallel scavenge(ps) 年轻代采用采用复制算法，多线程。<br>  parallel old(po) 老年代采用整理算法，多线程</p></li><li><p>并发收集器（jdk4版本时发明，但未被使用默认，其它收集器会有stw，效率较低。cms的stw时间很短，效率高）<br>  parNew（pararllel改良版） 年轻代采用复制算法，多线程。<br>  CMS 老年代采用标记清楚算法，多线程  </p><p>  <strong>CMS原理：</strong> 三色标记算法<br>  白色 : 还未被标记算法检索到<br>  灰色 : 自身被标记，下一级还没有被标记<br>  黑色 : 自身被标记，下一级也被标记<br>  多线程同时配合标记。<br>  <strong>浮动垃圾:</strong> 当对象引用被赋值为null置位垃圾对象的时候，但此时gcroots检索已经走完，导致此对象未来得急被标记为垃圾对象，叫浮动垃圾。<br>  <strong>漏标:</strong> 当对象引用被赋值为null垃圾对象的时候，又被其父父对象引用，但此时，gcroots已经检索到当前对象的父节点，其父父对象已经被标记过了，导致无法检索到当前对象，此时该对象会被当做垃圾对象。但实际上已经被父父对象引用而非垃圾对象，叫错标。解决方案：  </p><ol><li>写屏障<br>通过写屏障（类似aop切面）操作，监控引用对象在引用的时候如果是黑色的且当前对象为白色，就标记父级为灰色。</li><li>增量更新<br>只要有黑色对象新加了指向白色对象的引用关系，把这个新插入的引用记录下来，等并发扫描结束后，在将这个黑色对象为根重新扫描。  </li></ol><p>  <strong>CMS过程</strong></p><ol><li>初始标记（stw）</li><li>并发标记</li><li>重新标记（stw）</li><li>并发清除</li></ol><p>  <strong>CMS缺点：</strong> 有碎片垃圾。有错标，浮标问题。<br>  <strong>CMS优点：</strong> 可以与用户线程同时进行。</p></li></ul><hr><ul><li>G1回收处理器（jdk9默认使用）<br>  <strong>分区方法：</strong> G1默认是将堆划分为2048个大小相等的独立区域（Region），保留了概念隔离，不再是物理隔离，每个格子的角色不固定。格子分配比例年轻代8：1：1，年轻代默认占比5%。<br>  <strong>区别：</strong> Humongous（大对象），g1不像是之前的垃圾处理器，大对象直接放入老年代，g1开辟一个新空间存储大对象。<br>  <img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/Baize0805/img@master/Humongous.2t25ukbapp60.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Humongous"><br>  <strong>G1过程：</strong><ol><li>初始标记（stw）</li><li>并发标记</li><li>最终标记（stw）</li><li>筛选回收（stw）<br>此处cwt是与cms的主要区别，g1可以设置总ctw时间（-XX:MaxGCPauseMillis默认200ms），在gc之前会先预估回收时间，只做部分回收。预估时间的算法：内部会按照回收效益比排序，优先回收高的。<br>整体使用标记整理算法，使用复制算法实现：将存活对象复制到空白区域，然后将其它清除掉。<br><strong>Mixed Gc:</strong> 当老年代占有率达到参数（默认45%）设置的比例时触发,回收所有的年轻代和部分老年代（根据回收效益比计算）。<br><strong>young Gc：</strong> 再做youngGc之前会先计算本次清理时间是否到达设置的回收时间，如果没到，继续把年轻代增加空间。<br><strong>full Gc：</strong> 单线程收集，stw。<br><strong>缺点：</strong> 适合于大内存服务器，算法复杂，如果服务器内存小，效率不如cms，漏标：用SATB（原始快照）解决，与CMS区别，SATB效率更高。</li></ol></li><li>ZGC<br>  <a href="https://www.jianshu.com/p/4e4fd0dd5d25">ZGC原理与实现分析</a>,这篇文章将其解释的非常清晰！</li></ul><hr><h4 id="垃圾处理器的选择"><a href="#垃圾处理器的选择" class="headerlink" title="垃圾处理器的选择"></a>垃圾处理器的选择</h4><ol><li>4g以下的建议使用parallel</li><li>4-8g建议使用prarNew + cms</li><li>8g建议使用g1</li><li>百g建议使用ZGC</li></ol><hr><h4 id="CMS和G1的区别"><a href="#CMS和G1的区别" class="headerlink" title="CMS和G1的区别"></a>CMS和G1的区别</h4><p>堆空间上分配的不同：</p><ol><li>CMS收集器：将堆空间分成Eden、Servivor、old，并且他们是固定大小，JVM启动的时候设定且不能改变。</li><li>G1收集器：将堆空间分成多个大小相同的Region区域，逻辑上分Eden/Servivor、old，且大小是可变的，每次会根据GC的信息做出调整。</li><li>gc策略的不同：<br>CMS：存在minor GC、full GC，且CMS的年轻代使用（ParNew）去完成，老年代使用CMS去完成。<br>G1：区分三种策略，minor Gc、mixed GC 、 full GC, 而mixedGC会回收整个yong区，回收部分old区。</li></ol><hr><h4 id="minor-gc（年轻代gc）"><a href="#minor-gc（年轻代gc）" class="headerlink" title="minor gc（年轻代gc）"></a>minor gc（年轻代gc）</h4><p>用来回收年轻代里的垃圾对象，采用复制算法。</p><hr><h4 id="full-gc-Major-gc（老年代gc）"><a href="#full-gc-Major-gc（老年代gc）" class="headerlink" title="full gc/Major gc（老年代gc）"></a>full gc/Major gc（老年代gc）</h4><p>用来回收年轻代和老年代的垃圾对象，采用标记清除和标记整理算法。</p><hr><h4 id="老年代对象分配机制"><a href="#老年代对象分配机制" class="headerlink" title="老年代对象分配机制"></a>老年代对象分配机制</h4><ol><li>分代年龄达到15（默认，CMS收集器默认是6）。</li><li>大对象直接进入老年代（Eden区放不下即为大对象）。</li><li>对象年龄动态判断机制，当survivor内一批对象的大小总和超过区域的50%，就会直接进入老年代。</li><li>老年代空间分配担保机制。</li></ol><hr><h3 id="栈（线程）"><a href="#栈（线程）" class="headerlink" title="栈（线程）"></a><strong>栈（线程）</strong></h3><ul><li>每一个线程运行的时候，都会分配一块专属空间。</li><li>线程里的每一个方法运行都会在这块空间再分配一块栈帧。</li><li>栈帧<ul><li>局部变量表，int a;int b;如果是对象类型，存储的是堆的内存地址，指针引用的关系。</li><li>操作数栈，定义：当程序给变量赋值的时候，会把数值1压入到操作数栈里（进栈），然后把值赋值给局部变量a（出栈）。a=1;</li><li>动态链接，把符号引用转变成直接引用。常量池是存在方法区里，动态链接会把方法区的内存地址存储下来，程序运行到该方法的时候，会根据这个动态链接到方法区查找运行时常量。</li><li>方法出口,当调用方法时，就把返回行数信息存储在方法出口区域，当方法执行完毕后会根据存储的信息继续向下执行代码。</li></ul></li><li>当方法执行结束，栈帧即销毁</li><li>查看栈帧的执行过程<ul><li>通过反编译字节码文件,可查看底层执行过程（可查看JVM指令手册）。</li></ul></li></ul><hr><h3 id="栈（本地方法栈）"><a href="#栈（本地方法栈）" class="headerlink" title="栈（本地方法栈）"></a><strong>栈（本地方法栈）</strong></h3><ul><li>native修饰的方法叫本地方法</li><li>用来存储本地方法</li><li>本地方法可以看做是一个接口，底层是调用其它语言的入口，一般是c语言。</li></ul><hr><h3 id="方法区（元空间，永久代）"><a href="#方法区（元空间，永久代）" class="headerlink" title="方法区（元空间，永久代）"></a><strong>方法区（元空间，永久代）</strong></h3><ul><li>主要存储<ul><li>常量</li><li>静态变量</li><li>类信息，存储类的字节码信息</li></ul></li><li>如果存储的是对象信息，那么存储的也是堆内存地址。</li></ul><hr><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h3><ul><li>每一个线程运行的时候，都会分配一块专属空间，用来存储当前线程运行的内存地址,这块区域叫程序计数器</li><li>作用：当多个线程执行的时候，当前线程被其它优先级更高的线程中断，需要记录下当前线程的执行位置。以免继续执行的时候会重复执行</li><li>字节码执行引擎做修改</li></ul><hr><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a><strong>结构图</strong></h3><p><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/Baize0805/img@master/JVM.3pkenok0omy0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="JVM"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Compiled from &quot;JvmTest.java&quot;public class com.zyq.nat.controller.JvmTest &#123;  public com.zyq.nat.controller.JvmTest();    Code:       0: aload_0       1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V       4: return  public static void main(java.lang.String[]);    Code:       0: new           #2                  &#x2F;&#x2F; class com&#x2F;zyq&#x2F;nat&#x2F;controller&#x2F;JvmTest       3: dup       4: invokespecial #3                  &#x2F;&#x2F; Method &quot;&lt;init&gt;&quot;:()V       7: astore_1       8: aload_1       9: invokevirtual #4                  &#x2F;&#x2F; Method compute:()I      12: pop      13: return  public int compute();    Code:       0: iconst_1       1: istore_1       2: iconst_2       3: istore_2       4: iload_1       5: iload_2       6: iadd       7: bipush        10       9: imul      10: istore_3      11: iload_3      12: ireturn&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class JvmTest &#123;    public static final int initData &#x3D; 666;    public static User user &#x3D; new User();    public static void main(String[] args) &#123;        JvmTest jvmTest &#x3D; new JvmTest();        jvmTest.compute();    &#125;    public int compute()&#123;        int a &#x3D; 1;        int b &#x3D; 2;        int c &#x3D; (a + b) * 10;        return c;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="字节码执行引擎"><a href="#字节码执行引擎" class="headerlink" title="字节码执行引擎"></a><strong>字节码执行引擎</strong></h2><p>用途:修改程序计数器,创建gc垃圾回收线程。</p><hr><h2 id="jvm调优"><a href="#jvm调优" class="headerlink" title="jvm调优"></a><strong>jvm调优</strong></h2><ul><li>工具<ul><li>jvisualvm  命令行打开</li><li>arthas（常用），<a href="https://arthas.aliyun.com/doc/quick-start.html">阿里开源调优工具</a></li></ul></li><li>调优原因<br>jvm底层在做垃圾回收的时候，会暂停用户线程（STW,stop the world），所以要减少垃圾回收，oom。</li><li>核心目标<br>减少minorGC和full GC（主要）</li><li>参数配置<ul><li>Xmn：年轻代空间大小</li><li>Xss:每个线程栈大小</li><li>Xms：每个线程的初始堆大小，默认物理内存的1/64</li><li>Xmx：最小堆大小</li></ul></li><li>调优实例<ul><li>线上环境不能给图形化界面开放端口</li><li>压测环境使用图形化界面连接服务器</li><li>图形化界面远程链接连高可用集群中的一个，负载摘除，流量回放。</li></ul></li><li>cpu突然飙高怎么办<ol><li>定位-先查看是什么程序占用cpu：arthas-thread命令</li><li>看线程是业务线程还是系统线程<br>业务线程,查看调用栈，看看是哪个方法在占用cpu。<br>系统线程，查看gc问题，查看是哪里出现无法gc。</li></ol></li></ul><hr><h2 id="jvm类加载机制"><a href="#jvm类加载机制" class="headerlink" title="jvm类加载机制"></a><strong>jvm类加载机制</strong></h2><h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><ul><li>加载<br>写入jvm虚拟机的方法区，同时创建堆class对象</li><li>连接<ul><li>验证，校验字节码文件的正确性</li><li>准备，为类的静态变量分配内存并初始化默认值（如static int a= 5,此时只是分配默认值0，5会在初始化的时候赋值），预分配内存。</li><li>解析，把类中的符号引用转换为直接引用</li></ul></li><li>初始化<br>对类的静态变量初始化为指定的值，执行静态代码块</li></ul><hr><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ol><li>引导类加载器（Bootstrap Classloader）<br>负责加载jre/lib下的核心类库，底层由c++实现。</li><li>扩展类加载器(Extension Classloader)<br>负责加载jre/lib/ext下的1包。</li><li>应用类加载器(Application Classloader)<br>负责加载classpath下的class字节码文件。</li><li>自定义类加载器<br>负责加载用户自定义目录下的class文件。</li></ol><hr><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><ul><li>当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。</li><li>优点，避免类的重复加载，当父加载器已经加载过该类，没有必要子加载器再加载一遍，保证了唯一性。沙箱安全机制，自己写的String类不会被加载，可以防止核心api库被随意篡改</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study </tag>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于自学一年Java的感想</title>
      <link href="2021/06/06/guan-yu-zi-xue-yi-nian-java-de-gan-xiang/"/>
      <url>2021/06/06/guan-yu-zi-xue-yi-nian-java-de-gan-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="我"><a href="#我" class="headerlink" title="我"></a><strong>我</strong></h2><p><strong>目前就读：</strong> 江西环境工程职业学院<br><strong>专业：</strong> 软件技术<br><strong>爱好：</strong> 喜欢机甲<br><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/Baize0805/img@master/gdffff.ys6kt1ifwfk.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="自学"><a href="#自学" class="headerlink" title="自学"></a><strong>自学</strong></h2><h3 id="开端"><a href="#开端" class="headerlink" title="开端"></a><strong>开端</strong></h3><p>2019年开始懵懂的学习这个专业，因为学校为专科层次再加上学校自身的安排，所以我们一开学就开始学习技术。刚开始接触计算机什么都是新奇的，就连计算机的基本操作也是在那个学期开始学习。可想而知，我的第一个学期就这样过去了。<br>赶巧不巧，我的第二个学期又碰到到了全球性的疫情，对于一个专科生在家学习的状态可想而知。<br>疫情耗了大半个学期，终于可以返校了。我也是从这个时候正在开始接触java。</p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a><strong>入门</strong></h3><p>学校是应用型专科，所以基本上的知识补给都是在自学当中完成的。<br>我最开始自学是看B站 <strong><a href="https://space.bilibili.com/95256449/">遇见狂神说</a></strong> 这位博主的视频，视频的质量没得说是非常不错的。博主的生活和学习故事也是非常励志的，有兴趣的话大家可以去看看。奈何本人的基础有限，又一些视频的节奏属实有点更不上。所以我就换了个更加基础的教学视频。__<a href="https://space.bilibili.com/76542346/">动力节点</a>__ 它的教学视频可谓是细致入微，直到如今我还在学习他做的教学视频。</p><h3 id="今后"><a href="#今后" class="headerlink" title="今后"></a><strong>今后</strong></h3><p>当然是接着学习，IT这个行业的竞争太激烈了，大神比比皆是。新兴技术也是层出不穷，一句话：学无止境！！</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a><strong>感想</strong></h2><p>其实在选择这个计算机相关专业的时候，我个人觉得是挺简单的。可是在不断的学习下，才发现这个行业的水属实是有点深，这一年多的学习过程中有几次产生过放弃的想法。我能坚持下来很感谢和我一起自学的朋友和鄙视链这个东西。我想学IT行业的都有这个通病吧，喜欢怼身边的朋友，觉得他的技术就是不如自己。慢慢学下来发现，自己有点离不开技术了。几乎每天脑海里都会有这样的反射弧，只要是有关计算机的，都会去想它是怎么实现的，不断地去猜测。<br>学习是无止境的！吾日三省吾身！<br><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/Baize0805/img@master/wre.2pef193sqq00.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 随想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> live </tag>
            
            <tag> study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="2021/06/04/jian-zhan-di-yi-pian-bo-ke/"/>
      <url>2021/06/04/jian-zhan-di-yi-pian-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="心情"><a href="#心情" class="headerlink" title="心情"></a><strong>心情</strong></h1><ul><li>作为一个学习Java后端的小白，第一次使用前端框架搭建自己的个人博客，心情可想而知是非常激动的。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="规划"><a href="#规划" class="headerlink" title="规划"></a><strong>规划</strong></h1><ul><li>建立这个博客最大的目的就为了让我养成良好的做学习笔记的习惯，并尝试的写一些个人技术看法！就如河边的男孩终究是会长大的。😘<br><img "" class="lazyload placeholder" data-original="https://cdn.jsdelivr.net/gh/Baize0805/img@master/d4h.3vkxgmxvssw0.webp" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="d4h"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> live </tag>
            
            <tag> 建站小记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
